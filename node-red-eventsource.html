<script type="text/javascript">
    RED.nodes.registerType('EventSource', {
        category: 'network',
        color: '#E7E7AE',
        defaults: {
            name: { value: "" },
        },
        credentials: {
            url: { type: "text" },
            initDict: { type: "text" }
        },
        oneditprepare: function () {
            $("#node-input-initDict").typedInput({
                type: "json",
                types: ["json"]
            })
        },
        inputs: 1,
        outputs: 3,
        icon: "white-globe.svg",
        label: function () {
            return this.name || "EventSource";
        },
        inputLabels: "eventsource constructor parameters",
        outputLabels: ["sse", "onopen", "onerror"]
    });
</script>

<script type="text/html" data-template-name="EventSource">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-input-url"><i class="fa fa-tag"></i> URL</label>
        <input type="text" id="node-input-url" placeholder="http://localhost:8080/">
    </div>
    <div class="form-row">
        <label for="node-input-initDict"><i class="fa fa-tag"></i> initDict</label>
        <input type="text" id="node-input-initDict">
    </div>
</script>

<script type="text/markdown" data-help-name="EventSource">
Wrap the [eventsource](https://github.com/EventSource/eventsource) package as a node.

Used by a personal home automation flow: <https://github.com/parasaurolophus/waubesa>

See:

- <https://github.com/EventSource/eventsource>
- <https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events>
- <https://github.com/parasaurolophus/waubesa>

### Properties

_See the discussion of the `msg.payload.url` and `msg.payload.initDict` input message properties for a full discussion of the `url` and `initDict` properties in the node settings dialog. While setting these parameters in the node itself is supported, for most real world scenarios it is better to leave these empty and rely on passing messages into an `EventSource` node to control its state._

_Note also that the `url` and `initDict` properties are stored as encrypted credentials since they often contain sensitive information such as precise entity id's, access tokens and the like. This means that once set, they will be saved and restored when the flow is restarted but they will not be included when flows and subflows are exported. You can safely store flows that contain such configured nodes in a public version control repository, share flow snippets in wikis and fora and so on._

If a URL is set in the node settings dialog, the node will attempt to connect automatically each time the flow is (re-)started. Such a node will still respond to messages sent to its input port as described in the next section.

### Inputs

_Any parameters passed in an incoming message will override the corresponding parameters specified via the node's settings dialog._

If `msg.payload` is an object with a `url` property and, optionally, an `initDict` property then this node uses `new EventSource(msg.payload.url, msg.payload.initDict)` to wrap a newly created `eventsource` instance. The `initDict` defaults to an empty object (`{}`) if it is not supplied in `msg.payload`.

| Property               | Description                                                                                                                       |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| `msg.payload.url`      | (Required) URL of the SSE server                                                                                                  |
| `msg.payload.initDict` | (Optional) JavaScript object representation of the `eventSourceInitDict` parameter to `new EventSource(url, eventSourceInitDict)` |

Otherwise, if `msg.payload` is not an object or does not have a `url` property then this node calls the `eventsource.close()` method of the wrapped instance, if it exists.

### Outputs

1. Asynchronous stream of server-sent event objects
2. Asynchronous stream of `EventSource.onopen` life-cycle messages
3. Asynchronous stream of `EventSource.onerror` life-cycle messages

#### Output 1: Server-Sent Events

Each server-sent event object emitted from the first output will have `msg.payload.type` and `msg.payload.data` fields and `msg.topic` set to `"message"`. The content and format of the `type` and `data` properties are determined by the server:

    {
        topic: "message",
        payload: {
            type: "<...some string...>",
            data: "<...message body...>"
        }
    }

The default value for the `type` field defined by the [WHATWG](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events) specification is `"message"` but can be set to (almost) any string for a given event sent by a given server. The value of the `data` field may be anything that can be encoded in a HTTP response message.

#### Output 2: onopen

The second output will emit the objects sent to the `EventSource.onopen` handler. Each such object will have `msg.topic` set to `"open"` and `msg.payload` will be the value passed to the handler.

#### Output 3: onerror

The third output will emit the objects sent to the `EventSource.onerror` handler. Each such object will have `msg.topic` set to `"error"` and `msg.payload` will be the value passed to the handler. See <https://github.com/EventSource/eventsource#http-status-code-on-error-events> for information on the payload content.

### Details

This is a deliberately minimalist implementation of the protocol and JavaScript interface underlying the standard _EventSource_ feature available in modern web browsers. An aspect of the "minimalist" philoosophy is that an instance of `EventSource` wrapped by this node will automatically subscribe to and forward to the node's output **all** messages sent by the server, using an `EventSource.onmessage` handler. (In particular, it makes no attempt to expose the more fine grained `EventTarget.addEventListener(type, handler, ...)` interface.) To start receiving events, send a message with URL and configuration parameters in its payload as described above. The `EventSource` node will open a connection and begin emitting event messages asynchronously as they are sent by the server.

The `status.text` of the `EventSource` node can be used to track the state of the connection:

| `status.text` | Description                                                                                     |
|---------------|-------------------------------------------------------------------------------------------------|
| `-1`          | The `eventsource` client object has not yet been created since the flow was last (re-)started   |
|  `0`          | The `eventsource.readyState` value indicating the client is attempting to connect to the server |
|  `1`          | The `eventsource.readyState` value indicating the client is currently connected to the server   |
|  `2`          | The `eventsource.readyState` value indicating the connection has failed                         |

The `EventSource` node's status will oscillate between 0 and 1 as the wrapped `eventsource` instance attempts to stay connected. The `onopen` and `onerror` life-cycle messages described above are emitted along the way. If the status reaches 2, there will be no more attempts to reconnect automatically. You will need to send another `msg` to the `EventSource` node's input in order to resume receiving server-sent events.

> _Note that you must use a `status` node to track the 'eventsource.readyState' values described above rather than relying on the life-cycle messages in order to capture the current state of the connection. Due to deficiencies in the SSE specification and limitations in the `eventsource` package implementation, the life-cycle messages are useful mainly to provide diagnostics for particular, known network connection issues. Even the node status, which reflects the value of the `eventsource.readyState` property on an ongoing basis, is not 100% reliable as an indicator that the connection to the SSE server is healthy. For really critical applications, it may be wise to include an additional watchdog timer on output 1. Such a watchdog timer would send a new message with valid connection parameters to the `EventSource` node's input if an unexpectedly long time elapses with no server-sent event messages being received. Since what counts as "an unexpectedly long time" is application-specific, it is left as an exercise for the reader to add such checks rather than trying to build one-size-fits all error recovery logic into this node to supplement that which is already provided by the wrapped `eventsource` library. Similarly, it might be possible to detect and diagnose infrastructure issues by use of the contents of the error life-cycle events emitted from output 3. Again, since the details of what such messages might contain and how to interpret them is somewhat dependent on a particular deployment, no attempt is made to bake-in any particular error detection or recovery logic._

### Example Flows

There are four example flows provided in this package, of increasing complexity and completeness. You can watch the editor debug console panes while each is connected to a SSE server to see the `EventSource` node's status change to reflect the underlying `readyState` as well as the server-sent and life-cycle events it emits from its various outputs.

#### _basic-eventsource-example.json_

A single `EventSource` node with `debug` nodes connected to each of its outputs and a single `inject` node to let you experiment with manually closing a connection. You will have to configure the `url` and `initDict` values in the `EventSource` node's settings dialog. Once configured, the `EventSource` node will attempt to connect to your SSE server each time the flow is started and attempt to stay connected until the `inject` node named "close" is activated.

#### _dynamic-eventsource-example.json_

A single `EventSource` node with `debug` nodes connected to each of its outputs and two `inject` nodes to let you experiment with manually opening and closing a connection. You will have to configure the `url` and `initDict` values in the `inject` node named "open." Once configured, the `EventSource` node will attempt to connect to your SSE server each time the `inject` node named "open" is activated and attempt to stay connected until the `inject` node named "close" is activated.

#### _eventsource-with-automatic-reconnection.json_

This example builds on the preceding one by providing logic to detect when `eventsource.readyState` is 2 (`CLOSED`) and attempts automatically to reconnect. Here, the `url` and `initDict` parameters are in a `change` node named `set eventsource parameters`. Once connected, activating the `inject` node named "close" will activate a `trigger` node. When the `trigger` times out, the `EventSource` node will be reopened. Note that the `trigger` node is configured to automatically reset if the `readyState` indicates a successful reconnection before it times out.

#### _hue-sse.json_

This example wraps the "automatic reconnect" example in a subflow and adds a second subflow that parses the specific server-side event format emitted by a [Philips Hue Bridge](https://developers.meethue.com/develop/hue-api-v2/core-concepts/#events). If you have such a device, edit the `url` and `initDict` in the `change` node named `set eventsource parameters` in the subflow named `SSE` and then watch the debug pane for server-sent events as you turn on and off lights, your sensors report motion, temperature, light-level etc. Note that this example includes logic to parse the bridge's rather tortured payload into streams of somewhat more meaningful messages, one per resource whose state is being reported. (Even then, a fair amount of work needs to be done on the client side to correlate the payloads of various server-sent events and direct API queries to provide a meaningful interface to the state a given bridge's configured devices and groups, but I digress....)
</script>